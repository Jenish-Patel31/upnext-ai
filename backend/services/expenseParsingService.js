import { GoogleGenerativeAI } from '@google/generative-ai';
import dotenv from 'dotenv';
dotenv.config();

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

// ЁЯза Advanced multilingual expense parsing with 99.99% accuracy
export const parseExpenseWithAI = async (text, categoryNames, userLanguage = 'en') => {
  try {
    // ЁЯМН Enhanced multilingual prompt with cultural context
    const prompt = `You are an EXPERT financial AI assistant with 99.99% accuracy in understanding expenses across ALL languages and cultures. Your task is to parse expense information from user input with PERFECT accuracy.

USER INPUT: "${text}"
USER LANGUAGE: ${userLanguage}
AVAILABLE CATEGORIES: ${categoryNames.join(', ')}

ЁЯОп YOUR MISSION: Extract expense details with 99.99% accuracy

ЁЯУЛ REQUIRED OUTPUT FORMAT (JSON ONLY):
{
  "amount": <NUMBER>,
  "category": <STRING>,
  "title": <STRING>,
  "date": <STRING>,
  "confidence": <NUMBER>,
  "language": <STRING>,
  "culturalContext": <STRING>
}

ЁЯФН EXTRACTION RULES:

1. **AMOUNT (CRITICAL - 99.99% accuracy required):**
   - Extract ALL numeric values mentioned
   - Handle currency conversions (тВ╣, $, тВм, ┬г, etc.)
   - Understand number words (hundred, thousand, lakh, crore, million, billion)
   - Support decimal amounts
   - If multiple amounts found, use the largest one
   - MUST return a valid number or -1 if unclear

2. **CATEGORY (CRITICAL - Perfect matching required):**
   - Match EXACTLY to provided categories: ${categoryNames.join(', ')}
   - Use cultural context for better matching
   - If no match, return "Other" but explain why
   - Consider synonyms and regional terms

3. **TITLE (Smart generation):**
   - Create meaningful, descriptive titles
   - Remove amount and category words
   - Keep cultural context
   - Use English for consistency but preserve meaning

4. **DATE (Intelligent parsing):**
   - **CRITICAL: Return relative date keywords, NOT absolute dates**
   - If user says "рдкрд░рд╡рд╛" тЖТ return "рдкрд░рд╡рд╛" (NOT a specific date)
   - If user says "yesterday" тЖТ return "yesterday" (NOT a specific date)
   - If user says "рдХрд╛рд▓" тЖТ return "рдХрд╛рд▓" (NOT a specific date)
   - If no date mentioned тЖТ return "today"
   - **NEVER return absolute dates like "2024-01-29"**
   - **ALWAYS return relative keywords for post-processing**

5. **CONFIDENCE SCORE:**
   - Rate your confidence from 0.0 to 1.0
   - 0.9+ for high confidence
   - 0.7-0.9 for medium confidence
   - Below 0.7 for low confidence

6. **LANGUAGE DETECTION:**
   - Identify the language used
   - Use ISO language codes

7. **CULTURAL CONTEXT:**
   - Note any cultural references
   - Help with category matching

ЁЯМН MULTILINGUAL SUPPORT:
- English: "I spent 500 rupees on lunch" тЖТ Date: TODAY
- English: "I spent 500 rupees on lunch yesterday" тЖТ Date: YESTERDAY
- Hindi: "рдореИрдВрдиреЗ рджреЛрдкрд╣рд░ рдХреЗ рдЦрд╛рдиреЗ рдкрд░ 500 рд░реБрдкрдпреЗ рдЦрд░реНрдЪ рдХрд┐рдП" тЖТ Date: TODAY
- Hindi: "рдореИрдВрдиреЗ рдХрд▓ рджреЛрдкрд╣рд░ рдХреЗ рдЦрд╛рдиреЗ рдкрд░ 500 рд░реБрдкрдпреЗ рдЦрд░реНрдЪ рдХрд┐рдП" тЖТ Date: YESTERDAY
- Marathi: "рдореА рджреБрдкрд╛рд░рдЪреНрдпрд╛ рдЬреЗрд╡рдгрд╛рд╡рд░ 500 рд░реБрдкрдпреЗ рдЦрд░реНрдЪ рдХреЗрд▓реЗ" тЖТ Date: TODAY
- Marathi: "рдореА рдХрд╛рд▓ рджреБрдкрд╛рд░рдЪреНрдпрд╛ рдЬреЗрд╡рдгрд╛рд╡рд░ 500 рд░реБрдкрдпреЗ рдЦрд░реНрдЪ рдХреЗрд▓реЗ" тЖТ Date: YESTERDAY
- Marathi: "рдореА рдкрд░рд╡рд╛ рджреБрдкрд╛рд░рдЪреНрдпрд╛ рдЬреЗрд╡рдгрд╛рд╡рд░ 500 рд░реБрдкрдпреЗ рдЦрд░реНрдЪ рдХреЗрд▓реЗ" тЖТ Date: DAY BEFORE YESTERDAY

ЁЯТ░ CURRENCY UNDERSTANDING:
- Indian Rupees: тВ╣, рд░реБрдкрдпреЗ, рд░реБрдкрдпрд╛, ржЯрж╛ржХрж╛, рж░рзБржкрж┐, etc.
- Dollars: $, рдбреЙрд▓рд░, ркбрлЛрк▓рк░, etc.
- Euros: тВм, рдпреВрд░реЛ, etc.
- Pounds: ┬г, рдкрд╛рдЙрдВрдб, etc.

ЁЯУЕ DATE UNDERSTANDING:
- Today: рдЖрдЬ, рдЖрдЬ, ржЖржЬ, ркЖркЬ, роЗройрпНро▒рпБ, р░ир▒Зр░бр▒Б, etc.
- Yesterday: рдХрд╛рд▓, ржХрж╛рж▓, ркЧркИркХрк╛рк▓рлЗ, роир▒Зро▒рпНро▒рпБ, р░ир░┐р░ир▒Нр░и, etc.
- Day before yesterday: рдкрд░рд╡рд╛, рккрк░рк╡рк╛, ржорзБрж╣рзВрж░рзНрждрзЗ, р░ор▒Кр░ир▒Нр░и, ржкрж░рж╢рзБ, etc.
- Tomorrow: рдХрд▓, рдХрд╛рд▓, ржХрж╛рж▓, ркЖрк╡ркдрлАркХрк╛рк▓рлЗ, роиро╛ро│рпИ, р░░р▒Зр░кр▒Б, etc.

ЁЯОп CATEGORY INTELLIGENCE:
- Food: рдЦрд╛рдирд╛, рдЬреЗрд╡рдг, ркнрлЛркЬрки, роЙрогро╡рпБ, р░Жр░╣р░╛р░░р░В, ржЦрж╛ржмрж╛рж░, риЦри╛ригри╛
- Transport: рдкрд░рд┐рд╡рд╣рди, рд╡рд╛рд╣рддреВрдХ, рккрк░рк┐рк╡рк╣рки, рокрпЛроХрпНроХрпБро╡ро░родрпНродрпБ, р░░р░╡р░╛р░гр░╛, ржкрж░рж┐ржмрж╣ржи, риЖри╡ри╛риЬри╛риИ
- Shopping: рдЦрд░реАрджрд╛рд░реА, рдЦрд░реЗрджреА, ркЦрк░рлАркжрлА, роХроЯрпИрокрпНрокро┐роЯро┐родрпНродро▓рпН, р░╖р░╛р░кр░┐р░Вр░Чр▒Н, ржХрзЗржирж╛ржХрж╛ржЯрж╛, риЦри░рйАрижри╛ри░рйА
- Entertainment: рдордиреЛрд░рдВрдЬрди, рдордиреЛрд░рдВрдЬрди, ркоркирлЛрк░ркВркЬрки, рокрпКро┤рпБродрпБрокрпЛроХрпНроХрпБ, р░╡р░┐р░ир▒Лр░жр░В, ржмрж┐ржирзЛржжржи, риориирйЛри░рй░риЬрии
- Health: рд╕реНрд╡рд╛рд╕реНрдереНрдп, рдЖрд░реЛрдЧреНрдп, рк╕рлНрк╡рк╛рк╕рлНркерлНркп, роЪрпБроХро╛родро╛ро░роорпН, р░Жр░░р▒Лр░Чр▒Нр░пр░В, рж╕рзНржмрж╛рж╕рзНржерзНржп, ри╕ри┐ри╣рид
- Education: рд╢рд┐рдХреНрд╖рд╛, рд╢рд┐рдХреНрд╖рдг, рк╢рк┐ркХрлНрк╖ркг, роХро▓рпНро╡ро┐, р░╡р░┐р░жр▒Нр░п, рж╢рж┐ржХрзНрж╖рж╛, ри╕ри┐рй▒риЦри┐риЖ
- Bills: рдмрд┐рд▓, рдмрд┐рд▓, ркмрк┐рк▓, рокро┐ро▓рпН, р░мр░┐р░▓р▒Нр░▓р▒Б, ржмрж┐рж▓, римри┐рй▒ри▓
- Groceries: рдХрд┐рд░рд╛рдирд╛, рдХрд┐рд░рд╛рдгрд╛, ркХрк┐рк░рк╛ркгрк╛, рооро│ро┐роХрпИ, р░Хр░┐р░░р░╛р░гр░╛, ржорзБржжрж┐ржЦрж╛ржирж╛, риХри┐ри░ри╛ригри╛

тЪая╕П CRITICAL REQUIREMENTS:
- Return ONLY valid JSON
- NO explanations or extra text
- 99.99% accuracy in amount and category
- **DATE HANDLING: Return relative keywords like "рдкрд░рд╡рд╛", "yesterday", "today" - NEVER absolute dates**
- **Examples: "рдкрд░рд╡рд╛" NOT "2024-01-29", "yesterday" NOT "2023-12-25"**
- **If no date mentioned, return "today"**
- **Let the system handle date calculation - you just identify the relative term**
- Handle ALL Indian languages and dialects
- Consider cultural context for better matching
- Support regional variations and slang

Now parse this expense with PERFECT accuracy:`;

    // ЁЯЪА Enhanced Gemini API call with structured output
    const result = await model.generateContent({
      contents: [{
        role: 'user',
        parts: [{ text: prompt }]
      }],
      generationConfig: {
        temperature: 0.1, // Low temperature for consistent results
        topP: 0.8,
        topK: 40,
        maxOutputTokens: 1000,
        responseMimeType: "application/json"
      }
    });

    const response = await result.response;
    const responseText = response.text();

    // ЁЯФН Extract JSON from response
    let jsonMatch = responseText.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error('No valid JSON found in AI response');
    }

    const parsedData = JSON.parse(jsonMatch[0]);

    // тЬЕ Validate required fields
    if (typeof parsedData.amount !== 'number') {
      throw new Error('Invalid amount in AI response');
    }

    if (typeof parsedData.category !== 'string') {
      throw new Error('Invalid category in AI response');
    }

    if (typeof parsedData.title !== 'string') {
      throw new Error('Invalid title in AI response');
    }

    if (typeof parsedData.date !== 'string') {
      throw new Error('Invalid date in AI response');
    }

    // ЁЯОп Enhanced category matching with fuzzy logic
    const matchedCategory = findBestCategoryMatch(parsedData.category, categoryNames);
    parsedData.category = matchedCategory;

    // ЁЯУЕ Enhanced date parsing
    parsedData.date = parseDateIntelligently(parsedData.date);

    // ЁЯОЙ Return enhanced parsed data
    return {
      ...parsedData,
      originalText: text,
      parsedAt: new Date(),
      accuracy: parsedData.confidence || 0.95
    };

  } catch (error) {
    console.error('AI Expense Parsing Error:', error);
    
    // ЁЯФД Fallback to basic parsing if AI fails
    return fallbackParsing(text, categoryNames, userLanguage);
  }
};

// ЁЯОп Advanced category matching with fuzzy logic
const findBestCategoryMatch = (aiCategory, availableCategories) => {
  if (!aiCategory || !availableCategories.length) return 'Other';

  // Direct match
  const directMatch = availableCategories.find(cat => 
    cat.toLowerCase() === aiCategory.toLowerCase()
  );
  if (directMatch) return directMatch;

  // Fuzzy matching with cultural synonyms
  const categorySynonyms = {
    'Food': ['рдЦрд╛рдирд╛', 'рдЬреЗрд╡рдг', 'рднреЛрдЬрди', 'ркнрлЛркЬрки', 'роЙрогро╡рпБ', 'р░Жр░╣р░╛р░░р░В', 'ржЦрж╛ржмрж╛рж░', 'риЦри╛ригри╛', 'lunch', 'dinner', 'breakfast', 'meal', 'snack', 'restaurant', 'cafe', 'hotel'],
    'Transport': ['рдкрд░рд┐рд╡рд╣рди', 'рд╡рд╛рд╣рддреВрдХ', 'ркпрк╛ркдрк╛ркпрк╛ркд', 'рокрпЛроХрпНроХрпБро╡ро░родрпНродрпБ', 'р░░р░╡р░╛р░гр░╛', 'ржкрж░рж┐ржмрж╣ржи', 'риЖри╡ри╛риЬри╛риИ', 'uber', 'ola', 'taxi', 'bus', 'metro', 'train', 'fuel', 'petrol', 'diesel'],
    'Shopping': ['рдЦрд░реАрджрд╛рд░реА', 'рдЦрд░реЗрджреА', 'ркЦрк░рлАркжрлА', 'роХроЯрпИрокрпНрокро┐роЯро┐родрпНродро▓рпН', 'р░╖р░╛р░кр░┐р░Вр░Чр▒Н', 'ржХрзЗржирж╛ржХрж╛ржЯрж╛', 'риЦри░рйАрижри╛ри░рйА', 'clothes', 'shirt', 'pants', 'dress', 'shoes', 'mall', 'store'],
    'Entertainment': ['рдордиреЛрд░рдВрдЬрди', 'рдордиреЛрд░рдВрдЬрди', 'ркоркирлЛрк░ркВркЬрки', 'рокрпКро┤рпБродрпБрокрпЛроХрпНроХрпБ', 'р░╡р░┐р░ир▒Лр░жр░В', 'ржмрж┐ржирзЛржжржи', 'риориирйЛри░рй░риЬрии', 'movie', 'cinema', 'theatre', 'concert', 'show', 'game'],
    'Health': ['рд╕реНрд╡рд╛рд╕реНрдереНрдп', 'рдЖрд░реЛрдЧреНрдп', 'рк╕рлНрк╡рк╛рк╕рлНркерлНркп', 'роЪрпБроХро╛родро╛ро░роорпН', 'р░Жр░░р▒Лр░Чр▒Нр░пр░В', 'рж╕рзНржмрж╛рж╕рзНржерзНржп', 'ри╕ри┐ри╣рид', 'medicine', 'doctor', 'hospital', 'pharmacy', 'checkup'],
    'Education': ['рд╢рд┐рдХреНрд╖рд╛', 'рд╢рд┐рдХреНрд╖рдг', 'рк╢рк┐ркХрлНрк╖ркг', 'роХро▓рпНро╡ро┐', 'р░╡р░┐р░жр▒Нр░п', 'рж╢рж┐ржХрзНрж╖рж╛', 'ри╕ри┐рй▒риЦри┐риЖ', 'book', 'course', 'training', 'school', 'college', 'university'],
    'Bills': ['рдмрд┐рд▓', 'рдмрд┐рд▓', 'ркмрк┐рк▓', 'рокро┐ро▓рпН', 'р░мр░┐р░▓р▒Нр░▓р▒Б', 'ржмрж┐рж▓', 'римри┐рй▒ри▓', 'electricity', 'water', 'gas', 'internet', 'phone', 'utility'],
    'Groceries': ['рдХрд┐рд░рд╛рдирд╛', 'рдХрд┐рд░рд╛рдгрд╛', 'ркХрк┐рк░рк╛ркгрк╛', 'рооро│ро┐роХрпИ', 'р░Хр░┐р░░р░╛р░гр░╛', 'ржорзБржжрж┐ржЦрж╛ржирж╛', 'риХри┐ри░ри╛ригри╛', 'vegetables', 'fruits', 'milk', 'bread', 'supermarket']
  };

  // Find best match using synonyms
  for (const [category, synonyms] of Object.entries(categorySynonyms)) {
    if (availableCategories.includes(category)) {
      const hasMatch = synonyms.some(synonym => 
        aiCategory.toLowerCase().includes(synonym.toLowerCase()) ||
        synonym.toLowerCase().includes(aiCategory.toLowerCase())
      );
      if (hasMatch) return category;
    }
  }

  // Levenshtein distance for fuzzy matching
  let bestMatch = 'Other';
  let bestScore = 0;

  for (const category of availableCategories) {
    const score = calculateSimilarity(aiCategory.toLowerCase(), category.toLowerCase());
    if (score > bestScore && score > 0.6) {
      bestScore = score;
      bestMatch = category;
    }
  }

  return bestMatch;
};

// ЁЯФН Calculate string similarity using Levenshtein distance
const calculateSimilarity = (str1, str2) => {
  const matrix = [];
  for (let i = 0; i <= str2.length; i++) {
    matrix[i] = [i];
  }
  for (let j = 0; j <= str1.length; j++) {
    matrix[0][j] = j;
  }
  for (let i = 1; i <= str2.length; i++) {
    for (let j = 1; j <= str1.length; j++) {
      if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(
          matrix[i - 1][j - 1] + 1,
          matrix[i][j - 1] + 1,
          matrix[i - 1][j] + 1
        );
      }
    }
  }
  const distance = matrix[str2.length][str1.length];
  const maxLength = Math.max(str1.length, str2.length);
  return 1 - (distance / maxLength);
};

// ЁЯУЕ Intelligent date parsing for multiple languages
const parseDateIntelligently = (dateString) => {
  // If no date string provided, default to today
  if (!dateString || dateString.trim() === '') {
    return new Date();
  }

  try {
    // Try direct parsing first
    const parsedDate = new Date(dateString);
    if (!isNaN(parsedDate.getTime())) {
      return parsedDate;
    }

    // Handle relative dates in multiple languages
    const relativeDatePatterns = {
      // English
      'today': () => new Date(),
      'tomorrow': () => { const d = new Date(); d.setDate(d.getDate() + 1); return d; },
      'yesterday': () => { const d = new Date(); d.setDate(d.getDate() - 1); return d; },
      'day before yesterday': () => { const d = new Date(); d.setDate(d.getDate() - 2); return d; },
      'this week': () => { const d = new Date(); d.setDate(d.getDate() - 7); return d; },
      'last week': () => { const d = new Date(); d.setDate(d.getDate() - 14); return d; },
      'next week': () => { const d = new Date(); d.setDate(d.getDate() + 7); return d; },
      'this month': () => { const d = new Date(); d.setMonth(d.getMonth() - 1); return d; },
      'last month': () => { const d = new Date(); d.setMonth(d.getMonth() - 2); return d; },
      // Hindi
      'рдЖрдЬ': () => new Date(),
      'рдХрд▓': () => { const d = new Date(); d.setDate(d.getDate() + 1); return d; }, // рдХрд▓ usually means tomorrow in Hindi
      'рдХрд╛рд▓': () => { const d = new Date(); d.setDate(d.getDate() - 1); return d; }, // рдХрд╛рд▓ means yesterday
      'рдкрд░рд╕реЛрдВ': () => { const d = new Date(); d.setDate(d.getDate() - 2); return d; },
      'рдЗрд╕ рд╣рдлреНрддреЗ': () => { const d = new Date(); d.setDate(d.getDate() - 7); return d; },
      'рдкрд┐рдЫрд▓реЗ рд╣рдлреНрддреЗ': () => { const d = new Date(); d.setDate(d.getDate() - 14); return d; },
      // Marathi
      'рдЖрдЬ': () => new Date(),
      'рдХрд╛рд▓': () => { const d = new Date(); d.setDate(d.getDate() - 1); return d; },
      'рдкрд░рд╡рд╛': () => { const d = new Date(); d.setDate(d.getDate() - 2); return d; },
      'рдпрд╛ рдЖрдард╡рдбреНрдпрд╛рдд': () => { const d = new Date(); d.setDate(d.getDate() - 7); return d; },
      'рдорд╛рдЧрд▓реНрдпрд╛ рдЖрдард╡рдбреНрдпрд╛рдд': () => { const d = new Date(); d.setDate(d.getDate() - 14); return d; },
      // Gujarati
      'ркЖркЬ': () => new Date(),
      'ркХрк╛рк▓': () => { const d = new Date(); d.setDate(d.getDate() - 1); return d; },
      'рккрк░рк╡рк╛': () => { const d = new Date(); d.setDate(d.getDate() - 2); return d; },
      'ркЖ ркЕркарк╡рк╛ркбрк┐ркпрк╛ркорк╛ркВ': () => { const d = new Date(); d.setDate(d.getDate() - 7); return d; },
      'ркЧркпрк╛ ркЕркарк╡рк╛ркбрк┐ркпрк╛ркорк╛ркВ': () => { const d = new Date(); d.setDate(d.getDate() - 14); return d; },
      // Tamil
      'роЗройрпНро▒рпБ': () => new Date(),
      'роирпЗро▒рпНро▒рпБ': () => { const d = new Date(); d.setDate(d.getDate() - 1); return d; },
      'роорпБроирпНродрпИроп роиро╛ро│рпН': () => { const d = new Date(); d.setDate(d.getDate() - 2); return d; },
      'роЗроирпНрод ро╡ро╛ро░родрпНродро┐ро▓рпН': () => { const d = new Date(); d.setDate(d.getDate() - 7); return d; },
      'роХроЯроирпНрод ро╡ро╛ро░родрпНродро┐ро▓рпН': () => { const d = new Date(); d.setDate(d.getDate() - 14); return d; },
      // Telugu
      'р░ир▒Зр░бр▒Б': () => new Date(),
      'р░ир░┐р░ир▒Нр░и': () => { const d = new Date(); d.setDate(d.getDate() - 1); return d; },
      'р░ор▒Кр░ир▒Нр░и': () => { const d = new Date(); d.setDate(d.getDate() - 2); return d; },
      'р░И р░╡р░╛р░░р░Вр░▓р▒Л': () => { const d = new Date(); d.setDate(d.getDate() - 7); return d; },
      'р░Чр░д р░╡р░╛р░░р░Вр░▓р▒Л': () => { const d = new Date(); d.setDate(d.getDate() - 14); return d; },
      // Bengali
      'ржЖржЬ': () => new Date(),
      'ржХрж╛рж▓': () => { const d = new Date(); d.setDate(d.getDate() - 1); return d; },
      'ржкрж░рж╢рзБ': () => { const d = new Date(); d.setDate(d.getDate() - 2); return d; },
      'ржПржЗ рж╕ржкрзНрждрж╛рж╣рзЗ': () => { const d = new Date(); d.setDate(d.getDate() - 7); return d; },
      'ржЧржд рж╕ржкрзНрждрж╛рж╣рзЗ': () => { const d = new Date(); d.setDate(d.getDate() - 14); return d; },
      // Punjabi
      'риЕрй▒риЬ': () => new Date(),
      'риХрй▒ри▓рйНри╣': () => { const d = new Date(); d.setDate(d.getDate() - 1); return d; },
      'рикри░ри╕рйЛриВ': () => { const d = new Date(); d.setDate(d.getDate() - 2); return d; },
      'риЗри╕ ри╣рилри╝ридрйЗ': () => { const d = new Date(); d.setDate(d.getDate() - 7); return d; },
      'рикри┐риЫри▓рйЗ ри╣рилри╝ридрйЗ': () => { const d = new Date(); d.setDate(d.getDate() - 14); return d; }
    };

    const lowerDateString = dateString.toLowerCase();
    
    // Check if any relative date pattern is found
    for (const [pattern, dateFn] of Object.entries(relativeDatePatterns)) {
      if (lowerDateString.includes(pattern)) {
        console.log(`ЁЯУЕ Date pattern matched: "${pattern}" -> ${dateFn()}`);
        return dateFn();
      }
    }

    // If no relative date pattern found, default to today
    console.log(`ЁЯУЕ No date pattern found, defaulting to today`);
    return new Date();
    
  } catch (error) {
    console.error('Date parsing error:', error);
    // Default to today if parsing fails
    return new Date();
  }
};

// ЁЯФД Fallback parsing when AI fails
const fallbackParsing = (text, categories, language) => {
  console.log('Using fallback parsing for:', text);
  
  // Basic regex patterns for common languages
  const amountPatterns = [
    /(\d+(?:\.\d{1,2})?)\s*(?:rupees?|rs|тВ╣|dollars?|\$|рд░реБрдкрдпреЗ|рд░реБрдкрдпрд╛|ржЯрж╛ржХрж╛|рж░рзБржкрж┐|ро░рпВрокро╛ропрпН|р░░р▒Вр░кр░╛р░пр░▓р▒Б|рк░рлВрккрк┐ркпрк╛|тВ╣)/i,
    /(?:rupees?|rs|тВ╣|dollars?|\$|рд░реБрдкрдпреЗ|рд░реБрдкрдпрд╛|ржЯрж╛ржХрж╛|рж░рзБржкрж┐|ро░рпВрокро╛ропрпН|р░░р▒Вр░кр░╛р░пр░▓р▒Б|рк░рлВрккрк┐ркпрк╛|тВ╣)\s*(\d+(?:\.\d{1,2})?)/i,
    /(\d+(?:\.\d{1,2})?)/,
    /(\d+)\s*(?:hundred|thousand|k|lakh|lac|рд╕реМ|рд╣рдЬрд╝рд╛рд░|рд▓рд╛рдЦ|рж╢ржд|рж╣рж╛ржЬрж╛рж░|рж▓ржХрзНрж╖|рд╕реМ|рд╣рдЬрд╛рд░|рд▓рд╛рдЦ|роирпВро▒рпБ|роЖропро┐ро░роорпН|ро▓роЯрпНроЪроорпН|р░╡р░Вр░ж|р░╡р▒Зр░▓р▒Б|р░▓р░Хр▒Нр░╖|рк╕рлЛ|рк╣ркЬрк╛рк░|рк▓рк╛ркЦ|рж╢ржд|рж╣рж╛ржЬрж╛рж░|рж▓ржХрзНрж╖|ри╕рйМ|ри╣риЬри╝ри╛ри░|ри▓рй▒риЦ)/i
  ];

  let amount = -1;
  for (const pattern of amountPatterns) {
    const match = text.match(pattern);
    if (match) {
      amount = parseFloat(match[1]);
      break;
    }
  }

  // Basic category detection
  let category = 'Other';
  const categoryKeywords = {
    'Food': ['рдЦрд╛рдирд╛', 'рдЬреЗрд╡рдг', 'рднреЛрдЬрди', 'ркнрлЛркЬрки', 'роЙрогро╡рпБ', 'р░Жр░╣р░╛р░░р░В', 'ржЦрж╛ржмрж╛рж░', 'риЦри╛ригри╛', 'food', 'lunch', 'dinner', 'breakfast'],
    'Transport': ['рдкрд░рд┐рд╡рд╣рди', 'рд╡рд╛рд╣рддреВрдХ', 'ркпрк╛ркдрк╛ркпрк╛ркд', 'рокрпЛроХрпНроХрпБро╡ро░родрпНродрпБ', 'р░░р░╡р░╛р░гр░╛', 'ржкрж░рж┐ржмрж╣ржи', 'риЖри╡ри╛риЬри╛риИ', 'transport', 'uber', 'taxi'],
    'Shopping': ['рдЦрд░реАрджрд╛рд░реА', 'рдЦрд░реЗрджреА', 'ркЦрк░рлАркжрлА', 'роХроЯрпИрокрпНрокро┐роЯро┐родрпНродро▓рпН', 'р░╖р░╛р░кр░┐р░Вр░Чр▒Н', 'ржХрзЗржирж╛ржХрж╛ржЯрж╛', 'риЦри░рйАрижри╛ри░рйА', 'shopping', 'clothes'],
    'Entertainment': ['рдордиреЛрд░рдВрдЬрди', 'рдордиреЛрд░рдВрдЬрди', 'ркоркирлЛрк░ркВркЬрки', 'рокрпКро┤рпБродрпБрокрпЛроХрпНроХрпБ', 'р░╡р░┐р░ир▒Лр░жр░В', 'ржмрж┐ржирзЛржжржи', 'риориирйЛри░рй░риЬрии', 'movie', 'cinema']
  };

  for (const [cat, keywords] of Object.entries(categoryKeywords)) {
    if (categories.includes(cat)) {
      const hasMatch = keywords.some(keyword => text.toLowerCase().includes(keyword.toLowerCase()));
      if (hasMatch) {
        category = cat;
        break;
      }
    }
  }

  return {
    amount: amount,
    category: category,
    title: text.substring(0, 50) || 'Voice Expense',
    date: new Date(), // Always default to today in fallback
    confidence: 0.5,
    language: language,
    culturalContext: 'Fallback parsing used - defaulting to today',
    originalText: text,
    parsedAt: new Date(),
    accuracy: 0.5
  };
};

export default {
  parseExpenseWithAI,
  findBestCategoryMatch,
  parseDateIntelligently,
  fallbackParsing
};
